(self.webpackChunkinspection_scheduler=self.webpackChunkinspection_scheduler||[]).push([[1878],{4688:(e,t,s)=>{"use strict";s.d(t,{Z:()=>r});var i=s(59472);const r=class{constructor(e=Number.POSITIVE_INFINITY){this.size=0,this._start=0,this.maxSize=e,this._buffer=isFinite(e)?new Array(e):[]}get entries(){return this._buffer}enqueue(e){if(this.size===this.maxSize){const t=this._buffer[this._start];return this._buffer[this._start]=e,this._start=(this._start+1)%this.maxSize,t}return isFinite(this.maxSize)?this._buffer[(this._start+this.size++)%this.maxSize]=e:this._buffer[this._start+this.size++]=e,null}dequeue(){if(0===this.size)return null;const e=this._buffer[this._start];return this._buffer[this._start]=null,this.size--,this._start=(this._start+1)%this.maxSize,e}clear(){for(;(0,i.pC)(this.dequeue()););}}},41571:(e,t,s)=>{"use strict";s.d(t,{T:()=>I});var i=s(39105),r=s(50897),a=s(64345),n=s(18671),o=s(96781),l=s(95830),d=s(59472),u=s(36544),f=s(32656),c=s(71286),h=(s(5627),s(8634)),p=s(84570),y=(s(89930),s(83302)),m=s(22127);const g=u.Z.getLogger("esri.views.2d.engine.webgl.AttributeStoreView"),x=(0,m.g)(m.J,g),_=e=>2147483647&e;class v{constructor(e,t,s){this._texture=null,this._lastTexture=null,this._fbos={},this.texelSize=4;const{buffer:i,pixelType:r,textureOnly:a}=e,n=(0,y.UK)(r);this.shared=s,this.pixelType=r,this.size=t,this.textureOnly=a,a||(this.data=new n((0,d.Wg)(i))),this._resetRange()}destroy(){(0,d.Po)(this._texture,(e=>e.dispose()));for(const e in this._fbos)(0,d.Po)(this._fbos[e],(t=>{"0"===e&&t.detachColorTexture(),t.dispose()})),this._fbos[e]=null;this._texture=null}get _textureDesc(){return{target:3553,wrapMode:33071,pixelFormat:6408,dataType:this.pixelType,samplingMode:9728,width:this.size,height:this.size}}setData(e,t,s){const i=_(e),r=(0,d.Wg)(this.data),a=i*this.texelSize+t;!r||a>=r.length||(r[a]=s,this.dirtyStart=Math.min(this.dirtyStart,i),this.dirtyEnd=Math.max(this.dirtyEnd,i))}getData(e,t){if((0,d.Wi)(this.data))return null;const s=_(e)*this.texelSize+t;return!this.data||s>=this.data.length?null:this.data[s]}getTexture(e){return(0,d.Pt)(this._texture,(()=>this._initTexture(e)))}getFBO(e,t=0){if((0,d.Wi)(this._fbos[t])){const s={colorTarget:0,depthStencilTarget:0},i=0===t?this.getTexture(e):this._textureDesc;this._fbos[t]=new p.Z(e,s,i)}return this._fbos[t]}get locked(){return!(5121!==this.pixelType||!this.shared||this.textureOnly||!(0,l.Z)("esri-atomics")||!this.data)&&1===Atomics.load(this.data,0)}updateTexture(e){if(!this.locked)try{const t=this.dirtyStart,s=this.dirtyEnd;if(t>s)return;this._resetRange();const i=(0,d.Wg)(this.data).buffer,r=this.getTexture(e),a=4,n=(t-t%this.size)/this.size,o=(s-s%this.size)/this.size,l=n,u=this.size,c=o,h=n*this.size*a,p=(u+c*this.size)*a-h,m=(0,y.UK)(this.pixelType),x=m.BYTES_PER_ELEMENT;try{new m(i,h*x,p)}catch(e){console.debug(e)}const _=new m(i,h*x,p),v=this.size,D=c-l+1;if(D>this.size)return void g.error(new f.Z("mapview-webgl","Out-of-bounds index when updating AttributeData"));r.updateData(0,0,l,v,D,_)}catch(e){console.debug(e)}}update(e){const{data:t,start:s,end:i}=e;if((0,d.pC)(t)){const i=this.data,r=s*this.texelSize;for(let s=0;s<t.length;s++){const a=1<<s%this.texelSize;e.layout&a&&(i[r+s]=t[s])}}this.dirtyStart=Math.min(this.dirtyStart,s),this.dirtyEnd=Math.max(this.dirtyEnd,i)}resize(e,t){const s=this.size;if(this.size=t,this.textureOnly)return void(s!==this.size&&(this._lastTexture=this._texture,this._texture=null));const i=(0,y.UK)(this.pixelType);this.destroy(),this.data=new i((0,d.Wg)(e.buffer))}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0}_initTexture(e){const t=new h.Z(e,this._textureDesc,(0,d.Pt)(this.data,void 0));if((0,d.pC)(this._lastTexture)&&this._fbos[0]){const s=this._lastTexture.descriptor.width,i=this._lastTexture.descriptor.height,r=this._lastTexture.descriptor.dataType,a=this._lastTexture.descriptor.pixelFormat,n=this.getFBO(e),o=(0,y.Yw)(r),l=new((0,y.UK)(r))(new ArrayBuffer(s*i*o*this.texelSize)),d=e.getBoundFramebufferObject(),{x:u,y:f,width:c,height:h}=e.getViewport();e.bindFramebuffer(n),n.readPixels(0,0,s,i,a,r,l),t.updateData(0,0,0,2*s,i/2,l),e.setViewport(u,f,c,h),e.bindFramebuffer(d)}return this.destroy(),this._texture=t,this._texture}}class D{constructor(){this._initialized=!1,this._forceNextUpload=!1,this._locked=!1}initialize(e){const{blocks:t,shared:s,size:i}=e;if(this.shared=s,this.size=i,x("Initializing AttributeStoreView",e),(0,d.Wi)(this._data))this._data=(0,d.Fd)(t,(e=>new v(e,i,s)));else for(let e=0;e<this._data.length;e++){const r=this._data[e],a=t[e];(0,d.pC)(a)&&((0,d.Wi)(r)?this._data[e]=new v(a,i,s):r.resize(a,i))}this._initialized=!0}destroy(){(0,d.Po)(this._data,(e=>(0,d.Fd)(e,(e=>e.destroy())))),(0,d.Po)(this._defaultTexture,(e=>e.dispose()))}getBlock(e){return(0,d.Wi)(this._data)?null:this._data[e]}setLabelMinZoom(e,t){this.setData(e,0,1,t)}getLabelMinZoom(e){return this.getData(e,0,1,255)}getFilterFlags(e){return this.getData(e,0,0,0)}getVVSize(e){return this.getData(e,c.aK,0,0)}getData(e,t,s,i){if(!this._data)return 0;const r=(0,d.Wg)(this._data)[t];if((0,d.Wi)(r))return 0;const a=r.getData(e,s);return(0,d.pC)(a)?a:i}setData(e,t,s,i){const r=(0,d.Wg)(this._data)[t];(0,d.Wg)(r).setData(e,s,i)}lockTextureUpload(){this._locked=!0}unlockTextureUpload(){this._locked=!1}forceTextureUpload(){this._forceNextUpload=!0}async requestUpdate(e){if(this._pendingAttributeUpdate)return void g.error(new f.Z("mapview-webgl","Tried to update attribute data with a pending update"));const t=(0,i.createResolver)();return x("AttributeStoreView Update Requested",e),this._pendingAttributeUpdate={data:e,resolver:t},t.promise}update(){if(this._initialized&&(0,d.pC)(this._pendingAttributeUpdate)){const{data:e,resolver:t}=this._pendingAttributeUpdate,s=(0,d.Wg)(this._data);for(let t=0;t<e.blocks.length;t++){const i=e.blocks[t],r=s[t];(0,d.Po)(r,(e=>(0,d.Po)(i,(s=>{x(`Updating block ${t}`,s),e.update(s)}))))}this._pendingAttributeUpdate=null,t()}}bindTextures(e){this.update();const t=this._getDefaultTexture(e);if(!this._initialized)return e.bindTexture(t,c.iJ),e.bindTexture(t,c.nM),e.bindTexture(t,c.Ij),void e.bindTexture(t,c.f2);const s=(0,d.Wg)(this._data);this._locked&&!this._forceNextUpload||((0,d.JR)(s,(t=>t.updateTexture(e))),this._forceNextUpload=!1),e.bindTexture((0,d.R2)(s[0],t,(t=>t.getTexture(e))),c.iJ),e.bindTexture((0,d.R2)(s[1],t,(t=>t.getTexture(e))),c.nM),e.bindTexture((0,d.R2)(s[2],t,(t=>t.getTexture(e))),c.Ij),e.bindTexture((0,d.R2)(s[3],t,(t=>t.getTexture(e))),c.f2)}_getDefaultTexture(e){if((0,d.Wi)(this._defaultTexture)){const t={wrapMode:33071,pixelFormat:6408,dataType:5121,samplingMode:9728,width:1,height:1};this._defaultTexture=new h.Z(e,t,new Uint8Array(4))}return this._defaultTexture}}var b=s(55649),B=s(78745),L=s(96071),T=s(93533),F=s(2961),R=s(43129);function w(e,t){const s=t.length;if(e<t[0].value||1===s)return t[0].size;for(let i=1;i<s;i++)if(e<t[i].value){const s=(e-t[i-1].value)/(t[i].value-t[i-1].value);return t[i-1].size+s*(t[i].size-t[i-1].size)}return t[s-1].size}function C(e,t,s=0){if((0,d.Wi)(t))return e[s+0]=0,e[s+1]=0,e[s+2]=0,void(e[s+3]=0);const{r:i,g:r,b:a,a:n}=t;e[s+0]=i*n/255,e[s+1]=r*n/255,e[s+2]=a*n/255,e[s+3]=n}class z{constructor(){this.symbolLevels=[],this.vvColorValues=new Float32Array(8),this.vvColors=new Float32Array(32),this.vvOpacityValues=new Float32Array(8),this.vvOpacities=new Float32Array(8),this.vvSizeMinMaxValue=new Float32Array(4),this.ddColors=new Float32Array(32),this.ddBackgroundColor=new Float32Array(4),this.ddActiveDots=new Float32Array(8),this._vvMaterialParameters={vvSizeEnabled:!1,vvColorEnabled:!1,vvRotationEnabled:!1,vvRotationType:"geographic",vvOpacityEnabled:!1}}getSizeVVFieldStops(e){const t=this._vvSizeFieldStops;switch(t.type){case"static":return t;case"level-dependent":return(0,d.Pt)(t.levels[e],(()=>{let s=1/0,i=0;for(const r in t.levels){const t=parseFloat(r),a=Math.abs(e-t);a<s&&(s=a,i=t)}if(s===1/0)return{sizes:new Float32Array([0,0,0,0,0,0]),values:new Float32Array([0,0,0,0,0,0])};const r=e-i,a=Math.pow(2,r/2),n=(0,d.Wg)(t.levels[i]),o=new Float32Array(n.values);return o[2]*=a,o[3]*=a,{sizes:(0,d.Wg)(n.sizes),values:o}}))}}get vvMaterialParameters(){return this._vvMaterialParameters}update(e){(0,d.pC)(this._vvInfo)&&this._updateVisualVariables(this._vvInfo.vvRanges,e)}setInfo(e,t,s){switch((0,d.pC)(s)&&s.forEach((e=>this._updateEffects(e))),this._vvInfo=t,e.type){case"dot-density":this._updateDotDensityInfo(e)}}getVariation(){return{ddDotBlending:this.ddDotBlending,outsideLabelsVisible:this.outsideLabelsVisible,oesTextureFloat:(0,R.Z)().supportsTextureFloat}}getVariationHash(){return(this.ddDotBlending?1:0)|(this.outsideLabelsVisible?1:0)<<1}_updateEffects(e){(0,d.pC)(e)&&e.filter&&e.filter.enabled&&(this.outsideLabelsVisible=e.excludedLabelsVisible)}_updateVisualVariables(e,t){const s=this._vvMaterialParameters;if(s.vvOpacityEnabled=!1,s.vvSizeEnabled=!1,s.vvColorEnabled=!1,s.vvRotationEnabled=!1,!e)return;const i=e.size;if(i){if(s.vvSizeEnabled=!0,i.minMaxValue){const e=i.minMaxValue;let s,r;if((0,y.$K)(e.minSize)&&(0,y.$K)(e.maxSize))if((0,y.hj)(e.minSize)&&(0,y.hj)(e.maxSize))s=(0,L.F2)(e.minSize),r=(0,L.F2)(e.maxSize);else{const i=t.scale;s=(0,L.F2)(w(i,e.minSize.stops)),r=(0,L.F2)(w(i,e.maxSize.stops))}this.vvSizeMinMaxValue.set([e.minDataValue,e.maxDataValue,s,r])}if(i.scaleStops&&(this.vvSizeScaleStopsValue=(0,L.F2)(w(t.scale,i.scaleStops.stops))),i.unitValue){const e=(0,T.c9)(t.spatialReference)/F.a[i.unitValue.unit];this.vvSizeUnitValueToPixelsRatio=e/t.resolution}i.fieldStops&&(this._vvSizeFieldStops=i.fieldStops)}const r=e.color;r&&(s.vvColorEnabled=!0,this.vvColorValues.set(r.values),this.vvColors.set(r.colors));const a=e.opacity;a&&(s.vvOpacityEnabled=!0,this.vvOpacityValues.set(a.values),this.vvOpacities.set(a.opacities));const n=e.rotation;n&&(s.vvRotationEnabled=!0,s.vvRotationType=n.type)}_updateDotDensityInfo(e){const t=e.attributes;this.ddDotValue=e.dotValue,this.ddDotScale=e.referenceScale,this.ddDotSize=e.dotSize,this.ddDotBlending=e.dotBlendingEnabled,this.ddSeed=e.seed;for(let e=0;e<c.$0;e++){const s=e>=t.length?new B.Z([0,0,0,0]):t[e].color;C(this.ddColors,s,4*e)}for(let t=0;t<8;t++)this.ddActiveDots[t]=t<e.attributes.length?1:0;C(this.ddBackgroundColor,e.backgroundColor)}}class I extends b.Z{constructor(e){super(e),this._rendererInfo=new z,this._materialItemsRequestQueue=new a.Z,this.attributeView=new D}destroy(){this.removeAllChildren(),this.children.forEach((e=>e.destroy())),this.attributeView.destroy(),this._materialItemsRequestQueue.clear()}setRendererInfo(e,t,s){this._rendererInfo.setInfo(e,t,s),this.requestRender()}async getMaterialItems(e,t){if(!e||0===e.length)return null;const s=(0,i.createResolver)();return this._materialItemsRequestQueue.push({items:e,abortOptions:t,resolver:s}),this.requestRender(),s.promise}onTileData(e,t){if(t.addOrUpdate&&"tileDisplayData"in t.addOrUpdate)e.setData(t);else{const s=t.addOrUpdate&&n.M.decode(t.addOrUpdate),i={...t,addOrUpdate:s};e.setData(i)}this.contains(e)||this.addChild(e),this.requestRender()}onTileError(e){e.clear(),this.contains(e)||this.addChild(e)}doRender(e){if(e.context.capabilities.textureFloat,e.context.capabilities.vao,this._materialItemsRequestQueue.length>0){let t=this._materialItemsRequestQueue.pop();for(;t;)this._processMaterialItemRequest(e,t),t=this._materialItemsRequestQueue.pop()}super.doRender(e)}renderChildren(e){for(const t of this.children)t.commitChanges(e);this._rendererInfo.update(e.state),super.renderChildren(e)}createTile(e){const t=this._tileInfoView.getTileBounds((0,r.Ue)(),e);return new o.o(e,t)}destroyTile(e){this.removeChild(e),e.destroy()}createRenderParams(e){return{...super.createRenderParams(e),rendererInfo:this._rendererInfo,attributeView:this.attributeView}}_processMaterialItemRequest(e,{items:t,abortOptions:s,resolver:r}){const{painter:a,pixelRatio:n}=e,o=t.map((e=>a.textureManager.rasterizeItem(e.symbol,n,e.glyphIds,s)));(0,i.all)(o).then((e=>{if(!this.stage)return void r.reject();const s=e.map(((e,s)=>({id:t[s].id,mosaicItem:e})));r.resolve(s)}),r.reject)}}},55649:(e,t,s)=>{"use strict";s.d(t,{Z:()=>l});var i=s(31514),r=s(69822),a=s(87772),n=s(23956);const o=(e,t)=>e.key.level-t.key.level!=0?e.key.level-t.key.level:e.key.row-t.key.row!=0?e.key.row-t.key.row:e.key.col-t.key.col,l=class extends n.Z{constructor(e){super(),this._tileInfoView=e}renderChildren(e){this.sortChildren(o),this.setStencilReference(),super.renderChildren(e)}createRenderParams(e){const{state:t}=e;return{...super.createRenderParams(e),requiredLevel:this._tileInfoView.getClosestInfoForScale(t.scale).level,displayLevel:this._tileInfoView.tileInfo.scaleToZoom(t.scale)}}prepareRenderPasses(e){const t=e.registerRenderPass({name:"stencil",brushes:[a.Z],drawPhase:i.jx.DEBUG|i.jx.MAP|i.jx.HIGHLIGHT,target:()=>this.getStencilTarget()}),s=e.registerRenderPass({name:"tileInfo",brushes:[r.Z],drawPhase:i.jx.DEBUG,target:()=>this.children,has:"esri-tiles-debug"});return[...super.prepareRenderPasses(e),t,s]}getStencilTarget(){return this.children}updateTransforms(e){for(const t of this.children){const s=this._tileInfoView.getTileResolution(t.key);t.setTransform(e,s)}}setStencilReference(){let e=1;for(const t of this.children)t.stencilRef=e++}}},18671:(e,t,s)=>{"use strict";s.d(t,{M:()=>C});var i=s(31514),r=s(83302);const a=class{constructor(){this._byGeometryType=null}get satisfied(){return!this._byGeometryType}reset(){this._byGeometryType=null}verticesFor(e){return this._byGeometryType?this._byGeometryType[e].vertices:0}indicesFor(e){return this._byGeometryType?this._byGeometryType[e].indices:0}needMore(e,t,s){if(!t&&!s)return;this._byGeometryType||(this._byGeometryType=[{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0}]);const i=this._byGeometryType[e];i.vertices+=t,i.indices+=s}};class n{constructor(){this.geometries=[{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}}]}clone(){const e=new n;for(let t=0;t<this.geometries.length;t++){const s=this.geometries[t],i=e.geometries[t];i.indexBuffer=s.indexBuffer.slice(),i.vertexBuffer={};for(const e in s.vertexBuffer){const{data:t,stride:r}=s.vertexBuffer[e];i.vertexBuffer[e]={data:t.slice(),stride:r}}}return e}static deserialize(e){const t=new n;for(let s=0;s<5;++s){t.geometries[s].indexBuffer=new Uint32Array(e.geometries[s].indexBuffer),t.geometries[s].vertexBuffer={};for(const i in e.geometries[s].vertexBuffer)t.geometries[s].vertexBuffer[i]={data:(0,r.e2)(e.geometries[s].vertexBuffer[i].data,e.geometries[s].vertexBuffer[i].stride),stride:e.geometries[s].vertexBuffer[i].stride}}return t}serialize(){const e={geometries:[{indexBuffer:this.geometries[0].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[1].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[2].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[3].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[4].indexBuffer.buffer,vertexBuffer:{}}]};for(let t=0;t<5;++t)for(const s in this.geometries[t].vertexBuffer)e.geometries[t].vertexBuffer[s]={data:this.geometries[t].vertexBuffer[s].data.buffer,stride:this.geometries[t].vertexBuffer[s].stride};return e}getBuffers(){const e=[];for(let t=0;t<5;++t){e.push(this.geometries[t].indexBuffer.buffer);for(const s in this.geometries[t].vertexBuffer)e.push(this.geometries[t].vertexBuffer[s].data.buffer)}return e}}const o=n;var l=s(43862);const d=s(36544).Z.getLogger("esri.views.2d.engine.webgl.WGLDisplayList");function u(e,t,s,...i){t<e.length?e.splice(t,s,...i):e.push(...i)}const f=new Map;f.set(i.jx.MAP,[i.LW.FILL,i.LW.LINE,i.LW.MARKER,i.LW.TEXT]),f.set(i.jx.LABEL,[i.LW.LABEL]),f.set(i.jx.LABEL_ALPHA,[i.LW.LABEL]);class c{constructor(e=!1){this.symbolLevels=[],this.unified=e}replay(e,t,s){if(this.unified)for(const i of this.symbolLevels)for(const r of i.zLevels){const i=r.geometryDPInfo.unified;if(i)for(const r of i){const i=e.painter.getGeometryBrush(r.geometryType),a=t.getGeometry(r.geometryType);i.prepareState(e,t),i.drawGeometry(e,t,r,a,s)}}}get empty(){return!this.symbolLevels||0===this.symbolLevels.length}clear(){this.symbolLevels.length=0}addToList(e,t){if(Array.isArray(e))for(const s of e)this._addToList(s,t);else this._addToList(e,t)}removeFromList(e){Array.isArray(e)||(e=[e]);let t=null;for(const s of e)t=this._removeFromList(s);return t}byType(e,t){for(const s of this.symbolLevels)for(const i of s.zLevels){const s=i.geometryDPInfo,r=this.getDPInfoType(e);if(s[r])for(const e of s[r])t(e)}}clone(){const e=new c(this.unified);for(const t of this.symbolLevels)e.symbolLevels.push(t.clone());return e}splitAfter(e){const t=this._getDisplayList(e.symbolLevel,e.zOrder,e.geometryType),s=t.length,i=e.indexFrom+e.indexCount;for(let r=0;r<s;++r){const s=t[r];if(s.geometryType===e.geometryType&&i>s.indexFrom&&i<=s.indexFrom+s.indexCount){if(i<s.indexFrom+s.indexCount){const e=new h;e.geometryType=s.geometryType,e.materialKey=s.materialKey,e.indexFrom=i,e.indexCount=s.indexFrom+s.indexCount-i,t.splice(r+1,0,e),s.indexCount=i-s.indexFrom}return r}}}_addToList(e,t){const s=e.symbolLevel,i=e.zOrder,r=this._getDisplayList(s,i,e.geometryType),a=null!=t?t:r.length-1,n=a>=0&&a<r.length?r[a]:null;if(null===n||n.materialKey!==e.materialKey||n.indexFrom+n.indexCount!==e.indexFrom||this.unified&&n.geometryType!==e.geometryType){const t=new h;t.indexFrom=e.indexFrom,t.indexCount=e.indexCount,t.materialKey=e.materialKey,t.geometryType=e.geometryType,u(r,a+1,0,t)}else n.indexCount+=e.indexCount}_removeFromList(e){const t=e.symbolLevel,s=e.zOrder,i=this._getDisplayList(t,s,e.geometryType),r=i.length;let a;for(let t=0;t<r;++t){const s=i[t];if(e.indexFrom+e.indexCount>s.indexFrom&&e.indexFrom<s.indexFrom+s.indexCount&&(!this.unified||s.geometryType===e.geometryType)){a=t;break}}if(void 0!==a){const t=i[a];if(e.indexFrom===t.indexFrom)return t.indexCount-=e.indexCount,t.indexFrom+=e.indexCount,0===t.indexCount&&u(i,a,1),a-1;if(e.indexFrom+e.indexCount===t.indexFrom+t.indexCount)return t.indexCount-=e.indexCount,0===t.indexCount?(u(i,a,1),a-1):a;{const s=t.indexFrom,r=e.indexFrom-t.indexFrom,n=e.indexCount,o=t.indexFrom+t.indexCount-(e.indexFrom+e.indexCount);t.indexCount=r;const l=new h;return l.geometryType=t.geometryType,l.materialKey=t.materialKey,l.indexFrom=s+r+n,l.indexCount=o,u(i,a+1,0,l),a}}return null}_getDisplayList(e,t,s){let r;const a=this.symbolLevels.length;for(let t=0;t<a;t++)if(this.symbolLevels[t].symbolLevel===e){r=this.symbolLevels[t];break}let n;r||(r=new m,r.symbolLevel=e,this.symbolLevels.push(r));const o=r.zLevels.length;for(let e=0;e<o;e++)if(r.zLevels[e].zLevel===t){n=r.zLevels[e];break}let l;if(n||(n=new y,n.geometryDPInfo=new p,n.zLevel=t,r.zLevels.push(n)),this.unified)n.geometryDPInfo.unified||(n.geometryDPInfo.unified=[]),l=n.geometryDPInfo.unified;else switch(s){case i.LW.FILL:n.geometryDPInfo.fill||(n.geometryDPInfo.fill=[]),l=n.geometryDPInfo.fill;break;case i.LW.LINE:n.geometryDPInfo.line||(n.geometryDPInfo.line=[]),l=n.geometryDPInfo.line;break;case i.LW.MARKER:n.geometryDPInfo.marker||(n.geometryDPInfo.marker=[]),l=n.geometryDPInfo.marker;break;case i.LW.TEXT:n.geometryDPInfo.text||(n.geometryDPInfo.text=[]),l=n.geometryDPInfo.text;break;case i.LW.LABEL:n.geometryDPInfo.label||(n.geometryDPInfo.label=[]),l=n.geometryDPInfo.label;break;default:console.error("Trying to add a record with geometry type '"+s+"'.")}return l}getDPInfoType(e){if(this.unified)return"unified";switch(e){case i.LW.FILL:return"fill";case i.LW.LINE:return"line";case i.LW.MARKER:return"marker";case i.LW.TEXT:return"text";case i.LW.LABEL:return"label";default:return void d.error(`DisplayList: Tried to convert unknown geometryType: ${e}`)}}}class h{constructor(){this.materialKey=null,this.indexFrom=0,this.indexCount=0}clone(){const e=new h;return e.geometryType=this.geometryType,e.materialKey=this.materialKey,e.indexFrom=this.indexFrom,e.indexCount=this.indexCount,e}}class p{constructor(){this.fill=null,this.line=null,this.marker=null,this.text=null,this.label=null,this.unified=null}clone(){const e=new p;return e.fill=this.fill&&this.fill.map((e=>e.clone())),e.line=this.line&&this.line.map((e=>e.clone())),e.marker=this.marker&&this.marker.map((e=>e.clone())),e.text=this.text&&this.text.map((e=>e.clone())),e.label=this.label&&this.label.map((e=>e.clone())),e.unified=this.unified&&this.unified.map((e=>e.clone())),e}}class y{constructor(){this.geometryDPInfo=new p}clone(){const e=new y;return e.zLevel=this.zLevel,e.geometryDPInfo=this.geometryDPInfo.clone(),e}}class m{constructor(){this.zLevels=[]}clone(){const e=new m;e.symbolLevel=this.symbolLevel;for(const t of this.zLevels)e.zLevels.push(t.clone());return e}}const g=c;var x=s(78787),_=s(634);function v(e){const t=[[],[],[],[],[]],s=e;for(const e of s)for(const s of e.displayRecords)t[s.geometryType].push(s);return t}class D{constructor(){}get displayObjectRegistry(){if(!this._displayObjectRegistry){this._displayObjectRegistry=new Map;for(const e of this.displayObjects)this._displayObjectRegistry.set(e.id,e)}return this._displayObjectRegistry}get displayList(){return this._displayList}computeDisplayList(e){if(this._displayList=new g(e),e)for(const e of this.displayObjects)for(const t of e.displayRecords)this._displayList.addToList(t);else{const e=v(this.displayObjects),t=e.length;for(let s=0;s<t;++s){const t=e[s];this._displayList.addToList(t)}}}clone(){const e=new D;return this.displayObjects&&(e.displayObjects=this.displayObjects.map((e=>e.clone()))),e}serialize(e){return(0,x.G)(e,this.displayObjects),e}_deserializeObjects(e){const t=e.readInt32(),s=new Array(t),i=new Map;for(let t=0;t<s.length;++t){const r=_.Z.deserialize(e);s[t]=r,i.set(r.id,r)}this.displayObjects=s,this._displayList=null,this._displayObjectRegistry=i}static deserialize(e){const t=new D;return t._deserializeObjects(e),t}}const b=D;var B=s(7637),L=s(76939),T=s(65767);const F=new a,R=new a;function w(e,t){const s={};for(const i in e){const a={data:(0,r.C$)(t,e[i]),stride:e[i]};s[i]=a}return s}class C{constructor(){this.tileDisplayData=null,this.tileBufferData=null}reshuffle(){F.reset();const e=v(this.tileDisplayData.displayObjects);for(const t of e)for(const e of t)e&&F.needMore(e.geometryType,e.meshData?e.meshData.vertexCount:e.vertexCount,e.meshData?e.meshData.indexData.length:e.indexCount);const t=e.length,s=new o;for(let e=0;e<t;++e){s.geometries[e].indexBuffer=new Uint32Array(Math.round(1.5*F.indicesFor(e)));const t=[];for(const s in this.tileBufferData.geometries[e].vertexBuffer)t.push(this.tileBufferData.geometries[e].vertexBuffer[s].stride);const i=C._computeVertexAlignment(t),a=Math.round(1.5*F.verticesFor(e)),n=C._align(a,i);for(const t in this.tileBufferData.geometries[e].vertexBuffer){const i=this.tileBufferData.geometries[e].vertexBuffer[t].stride;s.geometries[e].vertexBuffer[t]={stride:i,data:(0,r.C$)(n,i)}}}R.reset(),this.tileDisplayData.displayList.clear();for(let i=0;i<t;++i){const t=e[i];for(const e of t){if(e.meshData)e.writeMeshDataToBuffers(R.verticesFor(i),s.geometries[i].vertexBuffer,R.indicesFor(i),s.geometries[i].indexBuffer),e.meshData=null;else{const t=this.tileBufferData.geometries[i].vertexBuffer,a=this.tileBufferData.geometries[i].indexBuffer,n=s.geometries[i].vertexBuffer,o=s.geometries[i].indexBuffer,l=R.verticesFor(i),d=R.indicesFor(i);(0,r.wO)(l,d,n,o,e,t,a),e.vertexFrom=l,e.indexFrom=d}R.needMore(i,e.vertexCount,e.indexCount)}this.tileDisplayData.displayList.unified||this.tileDisplayData.displayList.addToList(t)}if(this.tileDisplayData.displayList.unified)for(const e of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(e.displayRecords);this.tileBufferData=s}reshuffleBulkAdd(e,t,s){const a=e.addOrUpdate.tileDisplayData.displayObjects,n=this.tileDisplayData.displayObjects;F.reset();for(let e=0;e<n.length;e++){const t=n[e];for(let e=0;e<t.displayRecords.length;e++){const s=t.displayRecords[e];F.needMore(s.geometryType,s.vertexCount,s.indexCount)}}for(let e=t;e<a.length;e++){const i=a[e];for(let r=e===t?s:0;r<i.displayRecords.length;r++){const e=i.displayRecords[r];F.needMore(e.geometryType,e.vertexCount,e.indexCount)}}const l=new o;for(let e=0;e<5;e++){l.geometries[e].indexBuffer=new Uint32Array(Math.round(1.5*F.indicesFor(e)));const t=[],s=this.tileBufferData.geometries[e].vertexBuffer;for(const e in s)t.push(s[e].stride);const i=C._computeVertexAlignment(t),a=Math.round(1.5*F.verticesFor(e)),n=C._align(a,i);for(const t in s){const i=s[t].stride,a=(0,r.C$)(n,i);l.geometries[e].vertexBuffer[t]={stride:i,data:a}}}R.reset(),this.tileDisplayData.displayList.clear();for(let e=0;e<n.length;e++){const t=n[e];for(let e=0;e<t.displayRecords.length;e++){const s=t.displayRecords[e],i=s.geometryType,a=this.tileBufferData.geometries[i].vertexBuffer,n=this.tileBufferData.geometries[i].indexBuffer,o=l.geometries[i].vertexBuffer,d=l.geometries[i].indexBuffer,u=R.verticesFor(i),f=R.indicesFor(i);(0,r.wO)(u,f,o,d,s,a,n),s.vertexFrom=u,s.indexFrom=f,R.needMore(i,s.vertexCount,s.indexCount),this.tileDisplayData.displayList.addToList(s)}}const d=this.tileDisplayData.displayObjectRegistry;if(0!==s){const e=a[t];for(let t=0;t<s;t++){const s=e.displayRecords[t];if(d.get(e.id)&&s.geometryType!==i.LW.FILL&&s.geometryType!==i.LW.LINE)continue;const a=s.geometryType,n=this.tileBufferData.geometries[a].vertexBuffer,o=this.tileBufferData.geometries[a].indexBuffer,u=l.geometries[a].vertexBuffer,f=l.geometries[a].indexBuffer,c=R.verticesFor(a),h=R.indicesFor(a);(0,r.wO)(c,h,u,f,s,n,o),s.vertexFrom=c,s.indexFrom=h,R.needMore(a,s.vertexCount,s.indexCount),this.tileDisplayData.displayList.addToList(s)}}for(let n=t;n<a.length;n++){const o=a[n],u=n===t?s:0,f=d.get(o.id);for(let t=u;t<o.displayRecords.length;t++){const s=o.displayRecords[t];if(f){if(s.geometryType!==i.LW.FILL&&s.geometryType!==i.LW.LINE)continue;f.displayRecords.push(s)}const a=s.geometryType,n=e.addOrUpdate.tileBufferData.geometries[a],d=n.vertexBuffer,u=n.indexBuffer,c=l.geometries[a].vertexBuffer,h=l.geometries[a].indexBuffer,p=R.verticesFor(a),y=R.indicesFor(a);(0,r.wO)(p,y,c,h,s,d,u),s.vertexFrom=p,s.indexFrom=y,R.needMore(a,s.vertexCount,s.indexCount),this.tileDisplayData.displayList.addToList(s)}f||(d.set(o.id,o),this.tileDisplayData.displayObjects.push(o))}this.tileBufferData=l}getStrides(){const e=[];for(let t=0;t<this.tileBufferData.geometries.length;++t){const s=this.tileBufferData.geometries[t];e[t]={};for(const i in s.vertexBuffer)e[t][i]=s.vertexBuffer[i].stride}return e}clone(){const e=new C;return e.tileBufferData=this.tileBufferData.clone(),e.tileDisplayData=this.tileDisplayData.clone(),e}_guessSize(){const{displayObjects:e}=this.tileDisplayData,t=Math.min(e.length,4);let s=0;for(let i=0;i<t;i++)s=Math.max(s,e[i].displayRecords.length);return 2*(12*e.length+e.length*s*40)}serialize(){const e=this.tileBufferData.serialize(),t=this.tileBufferData.getBuffers(),s=this.tileDisplayData.serialize(new B.Z(Int32Array,this._guessSize())).buffer();return t.push(s),{result:{displayData:s,bufferData:e},transferList:t}}static decode(e){const t=L._.deserializeDisplayObjects(e),s={};for(const t in e.vertexBuffersMap)s[t]=T.g.decode(e.vertexBuffersMap[t]);return C.fromMeshData({displayObjects:t,vertexBuffersMap:s})}static fromMeshData(e){const t=new C,s=new b,i=new o;s.displayObjects=e.displayObjects;for(const t in e.vertexBuffersMap){const s=e.vertexBuffersMap[t];i.geometries[t].indexBuffer=s.indexBuffer,i.geometries[t].vertexBuffer=s.namedBuffers}return t.tileDisplayData=s,t.tileBufferData=i,t}static bind(e,t){const s=new C;return s.tileDisplayData=e,s.tileBufferData=t,s}static create(e,t){const s=new C;s.tileDisplayData=new b,s.tileDisplayData.displayObjects=e;const i=[0,0,0,0,0],r=[0,0,0,0,0],a=[[],[],[],[],[]];for(const t of e)for(const e of t.displayRecords)a[e.geometryType].push(e),i[e.geometryType]+=e.meshData.vertexCount,r[e.geometryType]+=e.meshData.indexData.length;const n=new o,d=function(e){return[e.fill||{},e.line||{},e.icon||{},e.text||{},e.label||{}]}(t);for(let e=0;e<5;e++){const t=new Uint32Array(r[e]),s=w(d[e],i[e]);l.Z.writeAllMeshDataToBuffers(a[e],s,t),n.geometries[e]={indexBuffer:t,vertexBuffer:s}}return s.tileBufferData=n,s}static _align(e,t){const s=e%t;return 0===s?e:e+(t-s)}static _computeVertexAlignment(e){let t=!1,s=!1;for(const i of e)i%4==2?t=!0:i%4!=0&&(s=!0);return s?4:t?2:1}}},9793:(e,t,s)=>{"use strict";s.d(t,{I:()=>o});s(95830);var i=s(98501),r=s(5201),a=s(55955),n=s(56291);class o extends n.s{constructor(e,t,s,i=s){super(),this.triangleCountReportedInDebug=0,this.transforms={dvs:(0,a.c)(),tileMat3:(0,a.c)()},this.triangleCount=0,this.key=new r.Z(e),this.bounds=t,this.size=s,this.coordRange=i}destroy(){this.texture&&(this.texture.dispose(),this.texture=null)}get coords(){return this._coords}get bounds(){return this._bounds}set bounds(e){this._coords=[e[0],e[3]],this._bounds=e}setTransform(e,t){const s=t/(e.resolution*e.pixelRatio),r=this.transforms.tileMat3,[a,n]=e.toScreenNoRotation([0,0],this.coords),o=this.size[0]/this.coordRange[0]*s,l=this.size[1]/this.coordRange[1]*s;(0,i.s)(r,o,0,0,0,l,0,a,n,1),(0,i.m)(this.transforms.dvs,e.displayViewMat3,r)}}},96781:(e,t,s)=>{"use strict";s.d(t,{o:()=>b});s(95830);var i=s(59472),r=s(4688),a=s(14286),n=s(71286),o=s(42738),l=s(87561),d=s(27851),u=s(9793),f=s(31514),c=s(83302);function h(e,t,s){if(!e.allDirty)if(null!=e.from&&null!=e.count){const i=Math.min(e.from,t),r=Math.max(e.from+e.count,t+s)-i;e.from=i,e.count=r}else e.from=t,e.count=s}const p=class{constructor(){this._dirties=(0,c.Mk)((()=>({indices:{from:null,count:null,allDirty:!1}})),(()=>({vertices:{from:null,count:null,allDirty:!1}})))}hasDirty(){for(const e of this._dirties)if(null!==e.data.indices.count||e.data.indices.allDirty)return!0;return!1}markAllClean(){for(const e of this._dirties){e.data.indices.from=null,e.data.indices.count=null,e.data.indices.allDirty=!1;for(const t in e.buffers)e.buffers[t].data.vertices.from=null,e.buffers[t].data.vertices.count=null,e.buffers[t].data.vertices.allDirty=!1}}markAllDirty(){for(const e of this._dirties){e.data.indices.allDirty=!0;for(const t in e.buffers)e.buffers[t].data.vertices.allDirty=!0}}forEach(e){for(let t=0;t<this._dirties.length;++t){const s=this._dirties[t],i={};for(const e in s.buffers){const t=s.buffers[e].data.vertices;(t.allDirty||null!=t.from&&null!=t.count&&t.count>0)&&(i[e]=t)}const r=s.data.indices;let a;a=r.allDirty||null!=r.from&&null!=r.count&&r.count>0?{indices:r,vertices:i}:{indices:null,vertices:i},(a.indices||Object.keys(a).length>0)&&e(a,t)}}markDirtyIndices(e,t,s){h(this._dirties[e].data.indices,t,s)}markDirtyVertices(e,t,s,i){h(this._dirties[e].buffers[t].data.vertices,s,i)}};class y{constructor(e){this._largestRange=null,this._parent=e,this._updateLargestRange()}get largestRange(){return this._largestRange}rangeCreated(e){(!this._largestRange||e.count>this._largestRange.count)&&(this._largestRange=e)}rangeResized(e,t){e===this._largestRange?e.count<t&&this._updateLargestRange():(!this._largestRange||e.count>this._largestRange.count)&&(this._largestRange=e)}findBestRange(e){let t=this._parent._freeHead,s=null;for(;null!==t;)t.count>=e&&(!s||t.count-e<s.count-e)&&(s=t),t=t.next;return s}findAdjacentRanges(e,t){let s=!0,i=!1,r=null,a=this._parent._freeHead;for(;s&&!i;){const n=null!==r?r.from+r.count:0,o=null!==a?a.from:this._parent._size;e>=n&&e+t<=o?(s=!1,i=!0):null!==a?(r=a,a=a.next):s=!1}return[r,a]}_updateLargestRange(){let e=null,t=this._parent._freeHead;for(;null!==t;)(!e||t.count>e.count)&&(e=t),t=t.next;this._largestRange=e}}class m{constructor(e,t){this._allocated=0,this._size=e,this._freeHead=e>0?{from:0,count:e,prev:null,next:null}:null,this._bookKeeper=t||new y(this),this._freeHead&&this._bookKeeper.rangeCreated(this._freeHead)}allocate(e){const t=this._bookKeeper.findBestRange(e);if(null===t)return-1;const s=t.from,i=t.count;if(t.from+=e,t.count-=e,this._bookKeeper.rangeResized(t,s,i),this._allocated+=e,0===t.count){const e=null!==t.prev?this._freeHead:t.next;m._removeRange(t),this._freeHead=e}return s}free(e,t){const[s,i]=this._bookKeeper.findAdjacentRanges(e,t),r={from:e,count:t,prev:s,next:i};if(null!==s&&(s.next=r),null!==i&&(i.prev=r),this._bookKeeper.rangeCreated(r),this._allocated-=t,null!==i&&r.from+r.count===i.from){const e=r.from,t=r.count;m._fuse(r,i),m._removeRange(i),this._bookKeeper.rangeResized(r,e,t),this._bookKeeper.rangeResized(i,void 0,0)}if(null!==s&&s.from+s.count===r.from){const e=s.from,t=s.count;m._fuse(s,r),m._removeRange(r),this._bookKeeper.rangeResized(s,e,t),this._bookKeeper.rangeResized(r,void 0,0)}this._freeHead=null!==r.prev?this._freeHead:r}get fragmentation(){const e=this._size-this._allocated;return 0===e?0:1-this._bookKeeper.largestRange.count/e}static _removeRange(e){null!==e.prev?null!==e.next?(e.prev.next=e.next,e.next.prev=e.prev):e.prev.next=null:null!==e.next&&(e.next.prev=null)}static _fuse(e,t){e.count+=t.count,e.next=t.next,t.from+=t.count,t.count=0,null!==t.next&&(t.next.prev=e)}}const g=["FILL","LINE","MARKER","TEXT","LABEL"];class x{constructor(e,t,s,i){this._strides=e,this._displayList=t,this._freeListsAndStorage={},this._dirtyMap=null,this._dirtyMap=s;for(const t in e){this._freeListsAndStorage[t]={vtxFreeList:i?new m(i):null,idxFreeList:i?new m(i):null,vertexBuffers:{},indexBuffer:i?new Uint32Array(i):null};for(const s in e[t])this._freeListsAndStorage[t].vertexBuffers[s]={data:i?(0,c.C$)(i,e[t][s]):null,stride:e[t][s]}}}static fromTileData(e,t){const s=function(e){const t=e.getStrides(),s={};for(let e=0;e<t.length;e++)s[g[e]]=t[e];return s}(e),i=[0,0,0,0,0],r=[0,0,0,0,0],a=e.tileDisplayData.displayObjects;for(const e of a)for(const t of e.displayRecords)i[t.geometryType]=Math.max(i[t.geometryType],t.vertexFrom+t.vertexCount),r[t.geometryType]=Math.max(r[t.geometryType],t.indexFrom+t.indexCount);const n=new x(s,e.tileDisplayData.displayList,t,null);for(let t=0;t<e.tileBufferData.geometries.length;++t){const s=i[t],a=r[t],o=e.tileBufferData.geometries[t],l=g[t],d=n._storageFor(l),u=e.tileBufferData.geometries[t].indexBuffer;let f;d.indexBuffer=u,d.idxFreeList=new m(u.length),d.idxFreeList.allocate(a);for(const s in o.vertexBuffer){const i=e.tileBufferData.geometries[t].vertexBuffer[s];d.vertexBuffers[s].data=i.data,d.vertexBuffers[s].stride=i.stride;const r=(0,c.Y8)(i.stride),a=i.data.length*r/i.stride;f||(f=a)}d.vtxFreeList=new m(f),d.vtxFreeList.allocate(s)}return n}delete(e){const t=g[e.geometryType];this._freeVertices(t,e.vertexFrom,e.vertexCount),this._freeIndices(t,e.indexFrom,e.indexCount),this._displayList.removeFromList(e),e.vertexFrom=void 0,e.indexFrom=void 0}setMeshData(e,t,s,i,r){const a=g[e.geometryType];let n,o;e.meshData=null,void 0===e.vertexFrom?(o=t.vertexCount,n=this._allocateVertices(a,o)):t.vertexCount>e.vertexCount?(this._freeVertices(a,e.vertexFrom,e.vertexCount),o=t.vertexCount,n=this._allocateVertices(a,o)):t.vertexCount===e.vertexCount?(n=e.vertexFrom,o=e.vertexCount):(this._freeVertices(a,e.vertexFrom+t.vertexCount,e.vertexCount-t.vertexCount),n=e.vertexFrom,o=t.vertexCount);let l,d,u,f=!0;if(void 0===e.indexFrom?(l=r,u=t.indexCount,d=this._allocateIndices(a,u)):t.indexCount>e.indexCount?(l=this._displayList.removeFromList(e),this._freeIndices(a,e.indexFrom,e.indexCount),u=t.indexCount,d=this._allocateIndices(a,u)):t.indexCount===e.indexCount?(f=!1,d=e.indexFrom,u=e.indexCount):(l=this._displayList.removeFromList(e),this._freeIndices(a,e.indexFrom+t.indexCount,e.indexCount-t.indexCount),d=e.indexFrom,u=t.indexCount),-1!==n&&-1!==d){const r=this._storageFor(a);if((0,c.wO)(n,d,r.vertexBuffers,r.indexBuffer,t,s,i),e.vertexFrom=n,e.indexFrom=d,e.vertexCount=t.vertexCount,e.indexCount=t.indexCount,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const t in s)this._dirtyMap.markDirtyVertices(e.geometryType,t,e.vertexFrom,e.vertexCount)}return f&&this._displayList.addToList(e,l),!0}return-1!==n&&this._freeVertices(a,n,o),-1!==d&&this._freeIndices(a,d,u),e.setMeshDataFromBuffers(t,s,i),e.vertexFrom=void 0,e.vertexCount=0,e.indexFrom=void 0,e.indexCount=0,!1}tryAddMeshData(e,t){const s=t.vertexBuffer,i=t.indexBuffer,r=g[e.geometryType],a=this._allocateVertices(r,e.vertexCount);if(-1===a)return this._freeVertices(r,a,e.vertexCount),!1;const n=this._allocateIndices(r,e.indexCount);if(-1===n)return this._freeVertices(r,a,e.vertexCount),this._freeIndices(r,n,e.indexCount),!1;const o=this._storageFor(r);if((0,c.wO)(a,n,o.vertexBuffers,o.indexBuffer,e,s,i),e.vertexFrom=a,e.indexFrom=n,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const t in s)this._dirtyMap.markDirtyVertices(e.geometryType,t,a,e.vertexCount)}return this._displayList.addToList(e),!0}_allocateVertices(e,t){const s=this._storageFor(e),i=s.vtxFreeList.allocate(t);return-1===i||s.vtxFreeList.fragmentation>.5?-1:i}_freeVertices(e,t,s){this._storageFor(e).vtxFreeList.free(t,s)}_freeIndices(e,t,s){this._storageFor(e).idxFreeList.free(t,s)}_allocateIndices(e,t){const s=this._storageFor(e),i=s.idxFreeList.allocate(t);return-1===i||s.idxFreeList.fragmentation>.5?-1:i}_storageFor(e){return this._freeListsAndStorage[e]}_stridesFor(e,t){return this._strides[e][t]}}const _=x;s(33655),s(5627);var v=s(69595);s(84570),s(89930);const D=new Set;class b extends u.I{constructor(e,t,s=!1){super(e,t,[n.I_,n.I_]),this._data=null,this._displayList=null,this._wglBuffers=null,this._deferPatches=!1,this._dirtyMap=new p,this._labelIndex=null,this._lastCommitTime=0,this._patchQueue=new r.Z(100),this.fader=new class{constructor(e=400){this.duration=e,this._lastTime=0,this._elapsed=0,this._value=0,this._finished=!1}get value(){return this._value}reset(){this._lastTime=0,this._elapsed=0,this._value=0}step(){const e=performance.now();if(0===this._lastTime)return this._lastTime=e,this._value=0,!0;if(this._elapsed>=this.duration)return!0;const t=e-this._lastTime;return this._elapsed+=t,this._lastTime=e,this._value=Math.min(this._elapsed/this.duration,1),!1}},this._dirty=!0,this._replaceBuffers=!1,this._uploadsLocked=!1,this._hasData=!1,this._invalidated=!1,this.transforms.labelMat2d=(0,l.c)(),this._ensureCorrectZOrder=s,this._deferPatches=!s}destroy(){super.destroy(),this.clear()}get displayObjects(){var e;return null!=(e=this._displayObjects)?e:[]}get isDirty(){return this._dirty}get hasData(){return!!this._hasData}get labelIndex(){return this._labelIndex}set isDirty(e){this._dirty=e,this.requestRender()}getGeometry(e){return this._wglBuffers&&this._wglBuffers.has(e)?this._wglBuffers.get(e):null}getDisplayList(){return this._displayList}setTransform(e,t){super.setTransform(e,t);const s=this.transforms.labelMat2d,i=e.getScreenTransform(s,t),r=(0,d.c)();(0,a.t)(r,this.coords,i),(0,o.i)(s),(0,o.t)(s,s,r),(0,o.m)(s,e.viewMat2d,s)}setData(e){const t=e.addOrUpdate,s=e.remove;e.clear&&(this.clear(),this._patchQueue.clear(),this._hasData=!1),"replace"===e.type&&(this._replaceBuffers=!0,this._patchQueue.clear(),this._data=null),!this._data&&t&&t.tileDisplayData.displayObjects.length?(t.tileDisplayData.computeDisplayList(this._ensureCorrectZOrder),this._dirtyMap=new p,this._dispRecStore=_.fromTileData(t,this._dirtyMap),this._data=t,this._dirtyMap.markAllDirty(),this._hasData=!0,e.end&&this.ready()):this._data&&(t&&t.tileDisplayData.displayObjects.length||s.length)?this._deferPatches?this._patchQueue.enqueue(e):this._doPatchData(e):e.end&&this.ready(),e.end&&!this._data&&this.clear(),this.requestRender(),this.emit("change")}lockUploads(){this._uploadsLocked=!0}unlockUploads(){this._uploadsLocked=!1,this.requestRender()}commitChanges(e){if(!e.time||e.time!==this._lastCommitTime){if(this._lastCommitTime=e.time,this.fader.step()||this.requestRender(),this._patchQueue.size){const e=this._patchQueue.dequeue();(0,i.pC)(e)&&(e.end&&this.ready(),this._doPatchData(e),this.requestRender(),this._hasData=!0)}if(this._uploadsLocked)this.requestRender();else if(this.visible&&this._data){if(this._replaceBuffers)for(this._wglBuffers&&this._wglBuffers.dispose(),this._wglBuffers=null,this._replaceBuffers=!1;this._patchQueue.size;){const e=this._patchQueue.dequeue();(0,i.pC)(e)&&(e.end&&this.ready(),this._doPatchData(e),this._hasData=!0)}this._wglBuffers||(this._wglBuffers=new class{constructor(e){this.geometryMap=(0,c.Mk)((()=>({indexBuffer:v.Z.createIndex(e,35044),vao:null})),((t,s)=>({vertexBuffer:v.Z.createVertex(e,c.mR[s])})))}dispose(){for(let e=0;e<5;e++){const t=this.geometryMap[e];if(t){t.data.vao&&t.data.vao.dispose(!1),t.data.indexBuffer&&t.data.indexBuffer.dispose();for(const e in t.buffers)t.buffers[e]&&t.buffers[e].data.vertexBuffer.dispose()}}}get(e){const t=this.geometryMap[e],s={};for(const e in t.buffers)s[e]=t.buffers[e].data.vertexBuffer;return{indexBuffer:t.data.indexBuffer,get vao(){return t.data.vao},set vao(e){t.data.vao=e},vertexBufferMap:s}}has(e){return null!=this.geometryMap[e]}upload(e,t){t.forEach(((t,s)=>{this._upload(t,s,e)}))}_upload(e,t,s){if(e.indices&&(e.indices.allDirty?this._uploadIndices(s,t):null!=e.indices.from&&null!=e.indices.count&&this._uploadIndices(s,t,e.indices.from,e.indices.count)),e.vertices){const i=e.vertices;for(const e in i){const r=i[e];r.allDirty?this._uploadVertices(s,t,e):null!=r.from&&null!=r.count&&this._uploadVertices(s,t,e,r.from,r.count)}}}_uploadVertices(e,t,s,i,r){const a=this.geometryMap[t];if(!a)return;const n=e.geometries[t].vertexBuffer[s];if(!n)return;const o=n.stride,l=n.data.buffer;a.buffers[s]&&l.byteLength>0&&(null!=i&&null!=r?a.buffers[s].data.vertexBuffer.setSubData(l,i*o,i*o,(i+r)*o):a.buffers[s].data.vertexBuffer.setData(l))}_uploadIndices(e,t,s,i){const r=this.geometryMap[t];if(!r)return;const a=e.geometries[t].indexBuffer.buffer;r.data.indexBuffer&&a.byteLength>0&&(null!=s&&null!=i?r.data.indexBuffer.setSubData(a,4*s,4*s,4*(s+i)):r.data.indexBuffer.setData(a))}}(e.context)),(this._dirtyMap.hasDirty()||this._invalidated)&&(this._invalidated=!1,this._wglBuffers.upload(this._data.tileBufferData,this._dirtyMap),this._displayList=this._data.tileDisplayData.displayList.clone(),this._displayObjects=this._data.tileDisplayData.displayObjects.slice(),this._rebuildLabelIndex(),this._dirtyMap.markAllClean())}}}clear(){this._data=null,this._displayList=null,this._dispRecStore=null,this._wglBuffers&&(this._wglBuffers.dispose(),this._wglBuffers=null)}_doPatchData(e){try{if("new"===e.type){if(!e.addOrUpdate)return;this._invalidated=!0;const t=this._bulkAddFeatures(e);t&&(this._dirtyMap.markAllDirty(),this._data.reshuffleBulkAdd(e,t.objectIndex,t.recordIndex),this._dispRecStore=_.fromTileData(this._data,this._dirtyMap))}else this._invalidated=!0,this._patchData(e)||(this._dirtyMap.markAllDirty(),this._data.reshuffle(),this._dispRecStore=_.fromTileData(this._data,this._dirtyMap))}catch(e){}this.requestRender()}_rebuildLabelIndex(){var e,t;if(null!=(e=this._data)&&null!=(t=e.tileBufferData.geometries[f.LW.LABEL])&&t.indexBuffer.length){this.isDirty=!0,this._labelIndex=this._initLabelIndex();for(const e of this.displayObjects)for(const t of e.metrics)this._insertIntoLabelIndex(t)}}_insertIntoLabelIndex(e){e.xBucket<0||e.yBucket<0||e.yBucket>3||e.xBucket>3||this.labelIndex[e.yBucket][e.xBucket].push(e)}_initLabelIndex(){const e=[];for(let t=0;t<n.I_/n.V8;t++){e.push([]);for(let s=0;s<n.I_/n.V8;s++)e[t].push([])}return e}_bulkAddFeatures(e){const t=e.addOrUpdate.tileDisplayData.displayObjects,s=this._data.tileDisplayData.displayObjects,i=this._data.tileDisplayData.displayObjectRegistry;for(let r=0;r<t.length;r++){const a=t[r],n=i.get(a.id);for(let t=0;t<a.displayRecords.length;++t){const s=a.displayRecords[t];if(n){if(s.geometryType!==f.LW.FILL&&s.geometryType!==f.LW.LINE)continue;n.displayRecords.push(s)}const i=e.addOrUpdate.tileBufferData.geometries[s.geometryType];if(!this._dispRecStore.tryAddMeshData(s,i))return{objectIndex:r,recordIndex:t}}n||(i.set(a.id,a),s.push(a))}return null}_patchData(e){let t=!0;const s=e.addOrUpdate&&e.addOrUpdate.tileDisplayData&&e.addOrUpdate.tileDisplayData.displayObjects||[],i=(e.remove||[]).slice();for(const e of s)null!=e.insertAfter&&i.push(e.id);for(const e of i){const t=this._data.tileDisplayData.displayObjectRegistry.get(e);if(t){this._data.tileDisplayData.displayList.removeFromList(t.displayRecords);for(const e of t.displayRecords)this._dispRecStore.delete(e);this._data.tileDisplayData.displayObjectRegistry.delete(e);const s=this._data.tileDisplayData.displayObjects.indexOf(t);this._data.tileDisplayData.displayObjects.splice(s,1)}}for(const i of s){let s,r=this._data.tileDisplayData.displayObjectRegistry.get(i.id);if(r){const e=r.displayRecords;r.set(i),r.displayRecords=e;const t=r.displayRecords.length;for(let e=0;e<t;++e){const t=r.displayRecords[e],s=i.displayRecords[e];(e>=i.displayRecords.length||t.geometryType!==s.geometryType||t.symbolLevel!==s.symbolLevel||t.zOrder!==s.zOrder||t.materialKey!==s.materialKey)&&(this._dispRecStore.delete(r.displayRecords[e]),e<i.displayRecords.length&&(r.displayRecords[e]=void 0))}r.displayRecords.length=i.displayRecords.length,r.metrics=i.metrics}else{let e;r=i.copy(),r.displayRecords=[],this._data.tileDisplayData.displayObjectRegistry.set(i.id,r);const t=this._data.tileDisplayData.displayObjects;if(null!=r.insertAfter)if(s={},r.insertAfter>=0){const s=this._data.tileDisplayData.displayObjectRegistry.get(r.insertAfter);s?(e=t.indexOf(s)+1,e<t.length?t.splice(e,0,r):(t.push(r),e=t.length)):(t.push(r),e=t.length)}else t.unshift(r),e=0;else t.push(r),e=t.length;if(s){let r;if(this._data.tileDisplayData.displayList.unified)r=i.displayRecords.length>0?1:0;else{D.clear();for(const e of i.displayRecords){const t=this._data.tileDisplayData.displayList.getDPInfoType(e.geometryType);D.add(t)}r=D.size}let a=0;for(let i=e-1;i>=0&&a<r;--i)for(let e=t[i].displayRecords.length-1;e>=0&&a<r;--e){const r=t[i].displayRecords[e],n=this._data.tileDisplayData.displayList.getDPInfoType(r.geometryType);s[n]||(s[n]=r,++a)}}}const a=i.displayRecords.length;for(let n=0;n<a;++n){const a=i.displayRecords[n];let o=r.displayRecords[n];o?(o.meshData=a.meshData,o.materialKey=a.materialKey):(o=a.copy(),o.vertexFrom=void 0,o.indexFrom=void 0,r.displayRecords[n]=o);const l=a.geometryType,d=this._data.tileDisplayData.displayList.getDPInfoType(l),u=e.addOrUpdate.tileBufferData.geometries[l],f=u.vertexBuffer,c=u.indexBuffer;let h;s&&(h=s[d]?this._data.tileDisplayData.displayList.splitAfter(s[d]):-1),t=this._dispRecStore.setMeshData(o,a,f,c,h)&&t,s&&null!=o.indexFrom&&null!=o.indexFrom&&(s[d]=o)}}return t}}},22127:(e,t,s)=>{"use strict";s.d(t,{J:()=>r,g:()=>i});const i=(e,t)=>e&&((...e)=>t.warn("DEBUG:",...e))||(()=>null),r=!1},5358:(e,t,s)=>{"use strict";s.d(t,{I:()=>h,qc:()=>d});var i=s(59472),r=s(96071),a=s(71286),n=s(31514),o=s(51482),l=s(50682);function d(e,t){if(!e||!t)return e;switch(t){case"radius":case"distance":return 2*e;case"diameter":case"width":return e;case"area":return Math.sqrt(e)}return e}function u(e){return e.map((e=>function(e){return{value:e.value,size:(0,r.t_)(e.size)}}(e)))}function f(e){if("string"==typeof e||"number"==typeof e)return(0,r.t_)(e);const t=e;return{type:"size",expression:t.expression,stops:u(t.stops)}}const c=e=>{const t=[],s=[],i=u(e),n=i.length;for(let e=0;e<6;e++){const o=i[Math.min(e,n-1)];t.push(o.value),s.push(null==o.size?a.AI:(0,r.F2)(o.size))}return{values:new Float32Array(t),sizes:new Float32Array(s)}};function h(e){const t=e&&e.length>0?{}:null,s=t?{}:null;if(!t)return{vvFields:t,vvRanges:s};for(const i of e)if(i.field&&(t[i.type]=i.field),"size"===i.type){s.size||(s.size={});const e=i;switch((0,l.a)(e)){case n.X.SIZE_MINMAX_VALUE:s.size.minMaxValue={minDataValue:e.minDataValue,maxDataValue:e.maxDataValue,minSize:f(e.minSize),maxSize:f(e.maxSize)};break;case n.X.SIZE_SCALE_STOPS:s.size.scaleStops={stops:u(e.stops)};break;case n.X.SIZE_FIELD_STOPS:if(e.levels){const t={};for(const s in e.levels)t[s]=c(e.levels[s]);s.size.fieldStops={type:"level-dependent",levels:t}}else s.size.fieldStops={type:"static",...c(e.stops)};break;case n.X.SIZE_UNIT_VALUE:s.size.unitValue={unit:e.valueUnit,valueRepresentation:e.valueRepresentation}}}else if("color"===i.type)s.color=m(i);else if("opacity"===i.type)s.opacity=p(i);else if("rotation"===i.type){const e=i;s.rotation={type:e.rotationType}}return{vvFields:t,vvRanges:s}}function p(e){const t={values:[0,0,0,0,0,0,0,0],opacities:[0,0,0,0,0,0,0,0]};if("string"==typeof e.field){if(!e.stops)return null;{if(e.stops.length>8)return null;const s=e.stops;for(let e=0;e<8;++e){const i=s[Math.min(e,s.length-1)];t.values[e]=i.value,t.opacities[e]=i.opacity}}}else{if(!(e.stops&&e.stops.length>=0))return null;{const s=e.stops&&e.stops.length>=0&&e.stops[0].opacity;for(let e=0;e<8;e++)t.values[e]=1/0,t.opacities[e]=s}}return t}function y(e,t,s){e[4*t+0]=s.r/255,e[4*t+1]=s.g/255,e[4*t+2]=s.b/255,e[4*t+3]=s.a}function m(e){if((0,i.Wi)(e))return null;if(e.normalizationField)return null;const t={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};if("string"==typeof e.field){if(!e.stops)return null;{if(e.stops.length>8)return null;t.field=e.field;const s=e.stops;for(let e=0;e<8;++e){const i=s[Math.min(e,s.length-1)];t.values[e]=i.value,y(t.colors,e,i.color)}}}else{if(!(e.stops&&e.stops.length>=0))return null;{const s=e.stops&&e.stops.length>=0&&e.stops[0].color;for(let e=0;e<8;e++)t.values[e]=1/0,y(t.colors,e,s)}}for(let e=0;e<32;e+=4)(0,o.pr)(t.colors,e,!0);return t}}}]);
//# sourceMappingURL=1878.js.map