(self.webpackChunkinspection_scheduler=self.webpackChunkinspection_scheduler||[]).push([[5121],{634:(e,t,s)=>{"use strict";s.d(t,{Z:()=>h});var i=s(43862),r=s(78787),a=s(19310);class n{constructor(e){this.insertAfter=null,this.id=e,this.displayRecords=[],this.metrics=[]}copy(){const e=new n(this.id);return e.set(this),e}clone(){const e=new n(this.id);return e.displayRecords=this.displayRecords.map((e=>e.clone())),e.metrics=this.metrics.map((e=>e.clone())),e.insertAfter=this.insertAfter,e}set(e){this.id=e.id,this.displayRecords=e.displayRecords,this.metrics=e.metrics,this.insertAfter=e.insertAfter}serialize(e){return e.push(this.id),(0,r.G)(e,this.metrics),(0,r.G)(e,this.displayRecords),e}static deserialize(e){const t=e.readInt32(),s=new n(t),h={id:t},o=(0,r.h)(e,a.Z);return o.length&&(s.metrics=o),s.displayRecords=(0,r.h)(e,i.Z,h),s}}const h=n},43862:(e,t,s)=>{"use strict";s.d(t,{Z:()=>n});var i=s(83302);const r=class{constructor(){this.vertexData=new Map,this.vertexCount=0,this.indexData=[]}clear(){this.vertexData.clear(),this.vertexCount=0,this.indexData=[]}update(e,t,s){for(const t in e)this.vertexData.set(t,e[t]);for(const t in this.vertexData)null===e[t]&&this.vertexData.delete(t);this.vertexCount=t,this.indexData=s}};class a{constructor(e,t,s,i=0,r=0){this.id=e,this.geometryType=t,this.materialKey=s,this.minZoom=i,this.maxZoom=r,this.meshData=null,this.symbolLevel=0,this.zOrder=0,this.vertexFrom=0,this.vertexCount=0,this.indexFrom=0,this.indexCount=0}get sortKey(){return void 0===this._sortKey&&this._computeSortKey(),this._sortKey}clone(){return this.copy()}copy(){const e=new a(this.id,this.geometryType,this.materialKey);return e.vertexFrom=this.vertexFrom,e.vertexCount=this.vertexCount,e.indexFrom=this.indexFrom,e.indexCount=this.indexCount,e.zOrder=this.zOrder,e.symbolLevel=this.symbolLevel,e.meshData=this.meshData,e.minZoom=this.minZoom,e.maxZoom=this.maxZoom,e}setMeshDataFromBuffers(e,t,s){const a=new r;for(const s in t){const r=t[s].stride,n=t[s].data,h=[],o=(0,i.Y8)(r);for(let t=0;t<r*e.vertexCount/o;++t)h[t]=n[t+r*e.vertexFrom/o];a.vertexData.set(s,h)}a.indexData.length=0;for(let t=0;t<e.indexCount;++t)a.indexData[t]=s[t+e.indexFrom]-e.vertexFrom;a.vertexCount=e.vertexCount,this.meshData=a}readMeshDataFromBuffers(e,t){this.meshData?this.meshData.clear():this.meshData=new r;for(const t in e){const s=e[t].stride,r=e[t].data,a=[],n=(0,i.Y8)(s);for(let e=0;e<s*this.vertexCount/n;++e)a[e]=r[e+s*this.vertexFrom/n];this.meshData.vertexData.set(t,a)}this.meshData.indexData.length=0;for(let e=0;e<this.indexCount;++e)this.meshData.indexData[e]=t[e+this.indexFrom]-this.vertexFrom;this.meshData.vertexCount=this.vertexCount}writeMeshDataToBuffers(e,t,s,r){for(const s in t){const r=t[s].stride,a=this.meshData.vertexData.get(s),n=t[s].data,h=(0,i.Y8)(r);for(let t=0;t<r*this.meshData.vertexCount/h;++t)n[t+r*e/h]=a[t]}for(let t=0;t<this.meshData.indexData.length;++t)r[t+s]=this.meshData.indexData[t]+e;this.vertexFrom=e,this.vertexCount=this.meshData.vertexCount,this.indexFrom=s,this.indexCount=this.meshData.indexData.length}static writeAllMeshDataToBuffers(e,t,s){let i=0,r=0;for(const a of e)a.writeMeshDataToBuffers(i,t,r,s),i+=a.vertexCount,r+=a.indexCount}_computeSortKey(){this._sortKey=(31&this.symbolLevel)<<12|(127&this.zOrder)<<4|7&this.geometryType}serialize(e){return e.push(this.geometryType),e.push(this.materialKey),e.push(this.vertexFrom),e.push(this.vertexCount),e.push(this.indexFrom),e.push(this.indexCount),e.push(this.minZoom),e.push(this.maxZoom),e}static deserialize(e,t){const s=e.readInt32(),i=e.readInt32(),r=new a(t.id,s,i);return r.vertexFrom=e.readInt32(),r.vertexCount=e.readInt32(),r.indexFrom=e.readInt32(),r.indexCount=e.readInt32(),r.minZoom=e.readInt32(),r.maxZoom=e.readInt32(),r}}const n=a},19310:(e,t,s)=>{"use strict";s.d(t,{Z:()=>u});var i=s(36544),r=s(71286),a=s(27851),n=s(30026),h=s(78787);const o=i.Z.getLogger("esri/views/2d/engine/webgl/collisions/Metric");class l{constructor(e,t,s,i,r){this.id=e,this.range=t,this.boxes=null,this.minZoom=-1,this.size=0,this.directionX=0,this.directionY=0,this.offsetX=0,this.offsetY=0,this.placementPadding=0,this.anchor=(0,a.f)(s,i),this.baseZoom=r}add(e,t,s){e.x=e.x+t,e.y=e.y+s,this.bounds?this.boxes?(this.boxes.push(e),this.bounds.extend(e)):(this.boxes=[this.bounds,e],this.bounds=this.bounds.clone(),this.bounds.extend(e)):this.bounds=e}computeIndex(){const e=this.anchor[0],t=this.anchor[1],s=Math.floor(e/r.V8),i=Math.floor(t/r.V8);this.xBucket=s,this.yBucket=i;const a=r.I_/r.V8;if(this.hasVV)return this.xOverflow=a,void(this.yOverflow=a);this.xOverflow=Math.min(a,Math.ceil(2*this.bounds.width/r.V8)),this.yOverflow=Math.min(a,Math.ceil(2*this.bounds.height/r.V8))}findCollisionDelta(e){const t=this.bounds.findCollisionDelta(e.bounds),s=this.boxes&&this.boxes.length,i=e.boxes&&e.boxes.length;return Math.abs(t)>r.o4||!s&&!i?t:s&&i?this._boxesToBoxes(e):s?this._boxesToBox(e):this._boxToBoxes(e)}computeVVOffset(e,t){t||o.error("mapview-labeling",`Unable to compute label offset. Expected an evaluator function but found ${t}`);let s=this.size;if(this.hasVV){const i=t(e);s=isNaN(i)||null==i||i===1/0?this.size:i}this._computeOffset(s)}setPlacementOffset(e,t,s,i,r){this.hasVV=e,this.size=t,this.placementPadding=Math.round(s),this.directionX=i,this.directionY=r}clone(){const e=new l(this.id,this.range,this.anchor[0],this.anchor[1],this.baseZoom);return e.minZoom=this.minZoom,this.bounds&&(e.bounds=this.bounds.clone()),this.boxes&&(e.boxes=this.boxes.map((e=>e.clone()))),e.xBucket=this.xBucket,e.yBucket=this.yBucket,e.xOverflow=this.xOverflow,e.yOverflow=this.yOverflow,e.hasVV=this.hasVV,e.size=this.size,e.directionX=this.directionX,e.directionY=this.directionY,e.offsetX=this.offsetX,e.offsetY=this.offsetY,e}_boxToBoxes(e){let t=-1/0;for(const s of e.boxes){const e=this.bounds.findCollisionDelta(s);t=Math.max(e,t)}return t}_boxesToBox(e){let t=this.boxes[0].findCollisionDelta(e.bounds);for(let s=1;s<this.boxes.length;s++){const i=this.boxes[s].findCollisionDelta(e.bounds);t=Math.max(i,t)}return t}_boxesToBoxes(e){let t=-1/0;for(let s=0;s<this.boxes.length;s++){const i=this.boxes[s];for(const s of e.boxes){const e=i.findCollisionDelta(s);t=Math.max(e,t)}}return t}_computeOffset(e){this.offsetX=this.directionX*(e/2+this.placementPadding),this.offsetY=this.directionY*(e/2+this.placementPadding)}serialize(e){return e.push(this.id),this.bounds.serialize(e),e.push(this.range.from),e.push(this.range.count),e.push(this.anchor[0]),e.push(this.anchor[1]),e.push(this.baseZoom),e.push(this.hasVV?1:0),e.push(this.size),e.writeF32(this.directionX),e.writeF32(this.directionY),e.push(this.offsetX),e.push(this.offsetY),e.push(this.placementPadding),(0,h.G)(e,this.boxes),e}static deserialize(e){const t=e.readInt32(),s=n.Z.deserialize(e),i={from:e.readInt32(),count:e.readInt32()},r=e.readInt32(),a=e.readInt32(),o=e.readInt32(),u=e.readInt32(),c=e.readInt32(),d=e.readF32(),f=e.readF32(),p=e.readInt32(),b=e.readInt32(),y=e.readInt32(),_=(0,h.h)(e,n.Z),x=new l(t,i,r,a,o);return x.bounds=s,x.boxes=_,x.setPlacementOffset(!!u,c,y,d,f),x.offsetX=p,x.offsetY=b,x.computeIndex(),u||x._computeOffset(c),x}}const u=l},76939:(e,t,s)=>{"use strict";s.d(t,{_:()=>l});var i=s(43862),r=s(78787),a=s(19310),n=s(634);const h=class{constructor(e){this._pos=0,this._buffer=e,this._i32View=new Int32Array(this._buffer),this._f32View=new Float32Array(this._buffer)}readInt32(){return this._i32View[this._pos++]}readF32(){return this._f32View[this._pos++]}};var o=s(7637);class l{constructor(e,t){this.vertexVectorsMap=e,this._currentIndex=-1,this._currentRecordOffset=0,this._currentMetricOffset=0,this._currentMetrics=[];const s=4*(4*t.features+1),i=4*(8*t.records+1),r=4*(20*t.metrics+1);this._bufDisplayObjects=new o.Z(Uint32Array,s+4),this._bufDisplayRecords=new o.Z(Uint32Array,i+4),this._bufMetrics=new o.Z(Uint32Array,r+4),this._bufDisplayObjects.push(0),this._bufDisplayRecords.push(0),this._bufMetrics.push(0)}get vertexBuffersMap(){if(!this._vertexBuffersMap){this._vertexBuffersMap={};for(let e=0;e<this.vertexVectorsMap.length;e++)this._vertexBuffersMap[e]=this.vertexVectorsMap[e].intoBuffers();this.vertexVectorsMap=null}return this._vertexBuffersMap}get(e){return this.vertexVectorsMap[e]}currentDisplayRecordCount(){return this._bufDisplayRecords[this._currentRecordOffset]}writeDisplayObject(e,t){this._bufDisplayObjects.incr(0),this._currentIndex=this._bufDisplayObjects.push(e),this._bufDisplayObjects.push(t),this._bufDisplayObjects.push(0),this._bufDisplayObjects.push(0),this._currentRecordOffset=0,this._currentMetricOffset=0,this._currentMetrics=[]}hasDisplayRecords(){return!(0===this._currentRecordOffset)}endDisplayObject(){this.hasDisplayRecords()?this._currentMetrics&&(0===this._currentMetricOffset&&(this._bufDisplayObjects.setValue(this._currentIndex+3,this._bufMetrics.length),this._currentMetricOffset=this._bufMetrics.length),(0,r.G)(this._bufMetrics,this._currentMetrics)):this._rollbackDisplayObject()}writeDisplayRecord(e,t,s,i,r,a,n=0,h=0){0===this._currentRecordOffset&&(this._currentRecordOffset=this._bufDisplayRecords.push(0),this._bufDisplayObjects.setValue(this._currentIndex+2,this._currentRecordOffset)),this._bufDisplayRecords.incr(this._currentRecordOffset),this._bufDisplayRecords.push(e),this._bufDisplayRecords.push(t),this._bufDisplayRecords.push(s),this._bufDisplayRecords.push(i),this._bufDisplayRecords.push(r),this._bufDisplayRecords.push(a),this._bufDisplayRecords.push(n),this._bufDisplayRecords.push(h)}writeMetrics(e){e&&this._currentMetrics.push(...e)}static deserializeDisplayObjects(e){const{bufDisplayObjects:t,bufMetrics:s,bufRecords:o}=e,l=new h(t),u=new h(o),c=new h(s),d=[];let f=l.readInt32();for(u.readInt32(),c.readInt32();f--;){const e=l.readInt32(),t=l.readInt32(),s=l.readInt32(),h=l.readInt32(),o=new n.Z(e);0!==t&&(o.insertAfter=t),0!==s&&(o.displayRecords=(0,r.h)(u,i.Z,{id:e})),0!==h&&(o.metrics=(0,r.h)(c,a.Z)),d.push(o)}return d}encode(e,t){const s={};for(let e=0;e<this.vertexVectorsMap.length;e++){const i=this.vertexVectorsMap[e];s[e]={},i.transfer(s[e],t)}e.bufDisplayObjects=this._bufDisplayObjects.buffer(),e.bufRecords=this._bufDisplayRecords.buffer(),e.bufMetrics=this._bufMetrics.buffer(),t.push(e.bufDisplayObjects),t.push(e.bufMetrics),t.push(e.bufRecords),e.vertexBuffersMap=s,this.destroy()}destroy(){this.vertexVectorsMap=null,this._bufDisplayObjects=null,this._bufDisplayRecords=null,this._bufMetrics=null}_rollbackDisplayObject(){this._bufDisplayObjects.decr(0),this._bufDisplayObjects.seek(this._bufDisplayObjects.length-4),this._currentIndex=this._bufDisplayObjects.length}}},65767:(e,t,s)=>{"use strict";s.d(t,{g:()=>a});var i=s(83302);class r{constructor(e,t,s){this.data=e,this.stride=t,this.vertexCount=s}static decode(e){const t=(0,i.e2)(e.data,e.stride),s=e.stride,a=e.vertexCount;return new r(t,s,a)}static fromVertexVector(e){const t=(0,i.e2)(e.data.buffer(),e.stride),s=e.stride,a=e.vertexCount;return new r(t,s,a)}}class a{constructor(e,t,s){this.geometryType=e,this.indexBuffer=new Uint32Array(t),this.namedBuffers=s}static decode(e){const t=e.geometryType,s=e.indexBuffer,i={};for(const t in e.namedBuffers)i[t]=r.decode(e.namedBuffers[t]);return new a(t,s,i)}static fromVertexVectors(e){const t=e.geometryType,s=e.indexVector.buffer(),i={};for(const t in e.namedVectors)i[t]=r.fromVertexVector(e.namedVectors[t]);return new a(t,s,i)}}},7637:(e,t,s)=>{"use strict";s.d(t,{Z:()=>i});const i=class{constructor(e,t){this._pos=0;const s=t?this._roundToNearest(t,e.BYTES_PER_ELEMENT):40;this._array=new ArrayBuffer(s),this._buffer=new e(this._array),this._ctor=e}get length(){return this._pos}_roundToNearest(e,t){const s=Math.round(e);return s+(t-s%t)}_ensureSize(e){if(this._pos+e>=this._buffer.length){const t=this._roundToNearest(1.5*(this._array.byteLength+e*this._buffer.BYTES_PER_ELEMENT),this._buffer.BYTES_PER_ELEMENT),s=new ArrayBuffer(t),i=new this._ctor(s);i.set(this._buffer,0),this._array=s,this._buffer=i}}writeF32(e){this._ensureSize(1);const t=this._pos;return new Float32Array(this._array,4*this._pos,1)[0]=e,this._pos++,t}push(e){this._ensureSize(1);const t=this._pos;return this._buffer[this._pos++]=e,t}writeFixed(e){this._buffer[this._pos++]=e}setValue(e,t){this._buffer[e]=t}getValue(e){return this._buffer[e]}incr(e){this._buffer[e]++}decr(e){this._buffer[e]--}writeRegion(e){this._ensureSize(e.length);const t=this._pos;return this._buffer.set(e,this._pos),this._pos+=e.length,t}buffer(){const e=this._array.slice(0,4*this._pos);return this.destroy(),e}toArray(){const e=this._array,t=[];for(let s=0;s<e.byteLength/4;s++)t.push(e[s]);return t}seek(e){this._pos=e}destroy(){this._array=null,this._buffer=null}}},78787:(e,t,s)=>{"use strict";function i(e,t){if(null!==t){e.push(t.length);for(const s of t)s.serialize(e);return e}e.push(0)}function r(e,t,s){const i=e.readInt32(),r=new Array(i);for(let i=0;i<r.length;i++)r[i]=t.deserialize(e,s);return r}s.d(t,{h:()=>r,G:()=>i})},81129:(e,t,s)=>{"use strict";s.d(t,{Z:()=>o});var i=s(56140),r=(s(95830),s(36544),s(68055),s(79881)),a=s(87566),n=(s(10923),s(57002),s(86035),s(77204));let h=class extends n.r{constructor(e){super(e),this.tiles=new Map}destroy(){this.tiles.clear(),this.layer=this.layerView=this.tileInfoView=this.tiles=null}get updating(){return this.isUpdating()}acquireTile(e){const t=this.createTile(e);return t.once("isReady",(()=>this.notifyChange("updating"))),this.tiles.set(e.id,t),t}forceAttributeTextureUpload(){}forEachTile(e){this.tiles.forEach(e)}releaseTile(e){this.tiles.delete(e.key.id),this.disposeTile(e)}isUpdating(){let e=!0;return this.tiles.forEach((t=>{e=e&&t.isReady})),!e}setHighlight(){}invalidateLabels(){}requestUpdate(){this.layerView.requestUpdate()}};(0,i._)([(0,r.Cb)()],h.prototype,"layer",void 0),(0,i._)([(0,r.Cb)()],h.prototype,"layerView",void 0),(0,i._)([(0,r.Cb)()],h.prototype,"tileInfoView",void 0),(0,i._)([(0,r.Cb)()],h.prototype,"updating",null),h=(0,i._)([(0,a.j)("esri.views.2d.layers.features.tileRenderers.BaseTileRenderer")],h);const o=h},29291:(e,t,s)=>{"use strict";s.r(t),s.d(t,{default:()=>y});var i=s(56140),r=(s(95830),s(36544),s(68055),s(79881),s(87566)),a=(s(10923),s(57002),s(86035),s(50897)),n=s(96781),h=s(80717),o=s(5358),l=s(81129),u=s(39105),c=s(31514),d=s(32825),f=s(41571);class p extends f.T{constructor(e,t,s){super(e),this._pointToCallbacks=new Map,this._layer=s,this._layerView=t}renderChildren(e){this.attributeView.update(),this.hasAnimation&&e.painter.effects.integrate.draw(e,e.attributeView),super.renderChildren(e)}hitTest(e,t){const s=[e,t],i=(0,u.hh)();return this._pointToCallbacks.set(s,i),this.requestRender(),i.promise}doRender(e){const{minScale:t,maxScale:s}=this._layer,i=e.state.scale;i<=(t||1/0)&&i>=s&&super.doRender(e)}get hasAnimation(){return this.hasLabels}get hasLabels(){const e=this._layer.featureReduction,t=e&&"cluster"===e.type&&e.labelsVisible&&e.labelingInfo&&e.labelingInfo.length;return this._layer.labelingInfo&&this._layer.labelingInfo.length&&this._layer.labelsVisible||!!t}get labelsVisible(){return this._layer.labelsVisible}prepareRenderPasses(e){const t=e.registerRenderPass({name:"label",brushes:[d.U.label],target:()=>this.hasLabels?this.children:null,drawPhase:c.jx.LABEL|c.jx.LABEL_ALPHA}),s=e.registerRenderPass({name:"geometry",brushes:[d.U.fill,d.U.line,d.U.marker,d.U.text],target:()=>this.children,enableDefaultDraw:()=>!this._layerView.hasEffects,effects:[{apply:e.effects.outsideEffect,enable:()=>this._layerView.hasEffects,args:()=>this._layerView.effectLists.excluded},{apply:e.effects.insideEffect,enable:()=>this._layerView.hasEffects,args:()=>this._layerView.effectLists.included},{apply:e.effects.hittest,enable:()=>!!this._pointToCallbacks.size,args:()=>this._pointToCallbacks}]}),i=e.registerRenderPass({name:"highlight",brushes:[d.U.fill,d.U.line,d.U.marker,d.U.text],target:()=>this.children,drawPhase:c.jx.HIGHLIGHT,enableDefaultDraw:()=>!1,effects:[{apply:e.effects.highlight,enable:()=>!!this._layerView.hasHighlight()}]});return[...super.prepareRenderPasses(e),s,i,t]}}let b=class extends l.Z{install(e){const t=new p(this.tileInfoView,this.layerView,this.layer);this.featuresView=t,e.addChild(t)}uninstall(e){e.removeChild(this.featuresView),this.featuresView.destroy()}hitTest(e,t){return this.featuresView.hitTest(e,t)}supportsRenderer(e){return null!=e&&-1!==["simple","class-breaks","unique-value","dot-density","dictionary"].indexOf(e.type)}onConfigUpdate(e){let t=null;if("visualVariables"in e){const s=((0,h.a)(e).visualVariables||[]).map((e=>{const t=e.clone();return"normalizationField"in e&&(t.normalizationField=null),e.valueExpression&&"$view.scale"!==e.valueExpression&&(t.valueExpression=null,t.field="nop"),t}));t=(0,o.I)(s)}this.featuresView.setRendererInfo(e,t,this.layerView.effects)}onTileData(e){const t=this.tiles.get(e.tileKey);t&&this.featuresView.onTileData(t,e.data),this.layerView.view.labelManager.requestUpdate()}onTileError(e){const t=this.tiles.get(e.tileKey);t&&this.featuresView.onTileError(t)}forceAttributeTextureUpload(){this.featuresView.attributeView.forceTextureUpload()}lockGPUUploads(){this.featuresView.attributeView.lockTextureUpload(),this.tiles.forEach((e=>e.lockUploads()))}unlockGPUUploads(){this.featuresView.attributeView.unlockTextureUpload(),this.tiles.forEach((e=>e.unlockUploads()))}async getMaterialItems(e){return this.featuresView.getMaterialItems(e)}invalidateLabels(){this.featuresView.hasLabels&&(this.tiles.forEach((e=>e.isDirty=!0)),this.layerView.view.labelManager.requestUpdate())}createTile(e){const t=this.tileInfoView.getTileBounds((0,a.Ue)(),e),s=new n.o(e,t);return this.featuresView.hasLabels&&this.layerView.view.labelManager.addTile(this.layerView,s),s}disposeTile(e){this.featuresView.removeChild(e),this.featuresView.hasLabels&&this.layerView.view.labelManager.removeTile(this.layerView,e.key.id),e.destroy(),this.layerView.view.labelManager.requestUpdate()}};b=(0,i._)([(0,r.j)("esri.views.2d.layers.features.tileRenderers.SymbolTileRenderer")],b);const y=b}}]);
//# sourceMappingURL=5121.js.map